// SPDX-License-Identifier: Apache-2.0
import org.hiero.gradle.environment.EnvAccess

plugins {
    id("java")
    id("org.gradlex.reproducible-builds")
}

@Suppress("UnstableApiUsage") val rootDir = project.isolated.rootProject.projectDirectory
val versions = EnvAccess.toolchainVersions(rootDir, providers, objects)

val fullJavaVersion = versions.getting("jdk").get()
val majorJavaVersion = JavaVersion.toVersion(fullJavaVersion)
val currentJavaVersion = providers.systemProperty("java.version").get()

if (currentJavaVersion != fullJavaVersion) {
    val message =
        "Gradle runs with Java $currentJavaVersion. This project works best running with Java $fullJavaVersion. " +
            "\n - From commandline: change JAVA_HOME and/or PATH to point at Java $fullJavaVersion installation." +
            "\n - From IntelliJ: change 'Gradle JVM' in 'Gradle Settings' to point at Java $fullJavaVersion installation."

    logger.lifecycle("WARN: $message")
}

java {
    sourceCompatibility = majorJavaVersion
    targetCompatibility = majorJavaVersion
}

tasks.withType<JavaCompile>().configureEach {
    // Track the full Java version as input (e.g. 17.0.3 vs. 17.0.9).
    // By default, Gradle only tracks the major version as defined in the toolchain (e.g. 17).
    // Since the full version is encoded in 'module-info.class' files, it should be tracked as
    // it otherwise leads to wrong build cache hits.
    inputs.property("fullJavaVersion", currentJavaVersion)
    // make the Java compiler add the Module's version to the module-info.class file
    options.javaModuleVersion = provider { project.version as String }
    // run compiler in a separate JVM process (independent of toolchain setup)
    options.isFork = true
    // Make sure consistent line endings are used in files generated by annotation processors
    options.forkOptions.jvmArgs = listOf("-Dline.separator=\n")
}

tasks.jar {
    manifest {
        attributes["Implementation-Title"] = project.name
        attributes["Implementation-Version"] = project.version
    }
}

sourceSets.all {
    // 'assemble' compiles all sources, including all test sources
    tasks.assemble { dependsOn(tasks.named(classesTaskName)) }
}
